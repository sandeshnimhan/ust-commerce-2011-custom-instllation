import * as angular from 'angular';
declare module 'smartedit' {
// ******************************************************* 
// This file is automatically generated 
// Do not modify this file -- YOUR CHANGES WILL BE ERASED! 
// ******************************************************* 




export enum ContextualMenuItemMode {
    Small = "small",
    Compact = "compact"
}
export interface SlotAttributes {
    smarteditSlotId: string;
    smarteditSlotUuid: string;
}
export class ContextualMenuItemComponent implements OnInit, OnDestroy {
    
    mode: ContextualMenuItemMode;
    index: number;
    componentAttributes: ComponentAttributes;
    slotAttributes: SlotAttributes;
    itemConfig: IContextualMenuButton;
    classes: string;
    
    
    constructor(element: ElementRef<HTMLElement>);
    ngOnInit(): void;
    ngOnDestroy(): void;
    
    
    
}




export class SmarteditComponent {
    
    upgrade: UpgradeModule;
    
    constructor(elementRef: ElementRef, upgrade: UpgradeModule, injector: Injector, angularJSBootstrapIndicatorService: AngularJSBootstrapIndicatorService);
    ngAfterViewInit(): void;
}

export function deprecatedSince1905(): void;
export function deprecatedSince2005(): void;
export const deprecate: () => void;

/// <reference types="angular" />
/// <reference types="jquery" />
/// <reference types="eonasdan-bootstrap-datetimepicker" />
export class HtmlDirective {
    
    constructor($element: JQuery);
    $postLink(): void;
}







export class LegacySmartedit {
}

export * from './system/systemModule';
export * from './system/features/contextualMenu';
export * from './system/features/slotContextualMenu';


export class BaseContextualMenuComponent {
    active: boolean;
    status: {
        isopen: boolean;
    };
    
    isHybrisIcon(icon: string): boolean;
    setRemainOpen(key: string, remainOpen: boolean): void;
    showOverlay(): boolean;
}

/// <reference types="angular" />
/// <reference types="jquery" />




export class ContextualMenuDecoratorComponent extends BaseContextualMenuComponent implements OnInit, DoCheck, OnDestroy {
    
    
    
    
    
    
    smarteditComponentType: string;
    smarteditComponentId: string;
    smarteditContainerType: string;
    smarteditContainerId: string;
    smarteditCatalogVersionUuid: string;
    smarteditElementUuid: string;
    componentAttributes: ComponentAttributes;
    active: string;
    items: ContextualMenu;
    openItem: IContextualMenuButton;
    moreMenuIsOpen: boolean;
    slotAttributes: {
        smarteditSlotId: string;
        smarteditSlotUuid: string;
    };
    itemTemplateOverlayWrapper: PopupOverlayConfig;
    moreMenuPopupConfig: PopupOverlayConfig;
    moreButton: {
        displayClass: string;
        i18nKey: string;
    };
    
    
    
    
    
    constructor(yjQuery: JQueryStatic, element: ElementRef, contextualMenuService: IContextualMenuService, systemEventService: SystemEventService, componentHandlerService: ComponentHandlerService, nodeUtils: NodeUtils);
    ngDoCheck(): void;
    ngOnDestroy(): void;
    ngOnInit(): void;
    readonly smarteditSlotId: string;
    readonly smarteditSlotUuid: string;
    onInit(): void;
    toggleMoreMenu(): void;
    shouldShowTemplate(menuItem: IContextualMenuButton): boolean;
    onShowItemPopup(item: IContextualMenuButton): void;
    onHideItemPopup(hideMoreMenu?: boolean): void;
    onShowMoreMenuPopup(): void;
    onHideMoreMenuPopup(): void;
    hideAllPopups(): void;
    getItems(): ContextualMenu;
    showContextualMenuBorders(): boolean;
    triggerMenuItemAction(item: IContextualMenuButton, $event: Event): void;
    
    
}



export class ContextualMenuItemOverlayComponent {
    
    
    legacyController: CompileHtmlNgController;
    constructor(data: {
        item: IContextualMenuButton;
    }, parent: ContextualMenuDecoratorComponent);
    ngOnInit(): void;
    readonly item: IContextualMenuButton;
    
}

export * from './BaseContextualMenuComponent';
export * from './ContextualMenuDecoratorComponent';
export * from './ContextualMenuItemOverlayComponent';
export * from './MoreItemsComponent';


export class MoreItemsComponent {
    parent: ContextualMenuDecoratorComponent;
    constructor(parent: ContextualMenuDecoratorComponent);
}

export * from './SlotContextualMenuDecoratorComponent';
export * from './SlotContextualMenuItemComponent';

/// <reference types="angular" />
/// <reference types="jquery" />




export class SlotContextualMenuDecoratorComponent extends BaseContextualMenuComponent implements OnInit, OnDestroy, OnChanges, DoCheck {
    
    
    
    
    
    
    smarteditComponentType: string;
    smarteditComponentId: string;
    smarteditContainerType: string;
    smarteditContainerId: string;
    smarteditSlotId: string;
    smarteditSlotUuid: string;
    smarteditCatalogVersionUuid: string;
    smarteditElementUuid: string;
    componentAttributes: ComponentAttributes;
    active: string;
    showItems: boolean;
    items: ContextualMenu;
    itemsrc: string;
    
    
    
    
    
    
    
    
    
    constructor(element: ElementRef, yjQuery: JQueryStatic, systemEventService: SystemEventService, contextualMenuService: IContextualMenuService, permissionService: IPermissionService, nodeUtils: NodeUtils);
    ngOnChanges(changes: SimpleChanges): void;
    ngOnInit(): void;
    ngDoCheck(): void;
    ngOnDestroy(): void;
    updateItems(): void;
    triggerMenuItemAction(item: IContextualMenuButton, $event: Event): void;
    getItems(): ContextualMenu;
    
    
    
    
}



export class SlotContextualMenuItemComponent {
    parent: SlotContextualMenuDecoratorComponent;
    item: IContextualMenuButton;
    isHovered: boolean;
    legacyController: CompileHtmlNgController;
    constructor(parent: SlotContextualMenuDecoratorComponent);
    onMouseOver(): void;
    onMouseOut(): void;
    ngOnInit(): void;
    ngOnChanges(): void;
    
}




export class SystemModule {
}




export class AnnouncementService extends IAnnouncementService {
}


export class AuthenticationService extends IAuthenticationService {
}




export class CatalogVersionPermissionService extends ICatalogVersionPermissionService {
    constructor();
}

/// <reference types="angular" />
/// <reference types="jquery" />
/// <reference types="eonasdan-bootstrap-datetimepicker" />
/**
 * @ngdoc service
 * @name smarteditServicesModule.service:ComponentHandlerService
 *
 * @description
 * Handles all get/set component related operations
 */
export class ComponentHandlerService {
    
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getOverlay
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Retrieves a handler on the smartEdit overlay div
     * This method can only be invoked from the smartEdit application and not the smartEdit container.
     *
     * @return {JQuery} The #smarteditoverlay JQuery Element
     */
    getOverlay(): JQuery;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#isOverlayOn
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * determines whether the overlay is visible
     * This method can only be invoked from the smartEdit application and not the smartEdit iframe.
     *
     * @return {boolean} true if the overlay is visible
     */
    isOverlayOn(): boolean;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getComponentUnderSlot
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Retrieves the yjQuery wrapper around a smartEdit component identified by its smartEdit id, smartEdit type and an optional class
     * This method can only be invoked from the smartEdit application and not the smartEdit container.
     *
     * @param {String} smarteditComponentId the component id as per the smartEdit contract with the storefront
     * @param {String} smarteditComponentType the component type as per the smartEdit contract with the storefront
     * @param {String} smarteditSlotId the slot id of the slot containing the component as per the smartEdit contract with the storefront
     * @param {String =} cssClass the css Class to further restrict the search on. This parameter is optional.
     *
     * @return {JQuery} a yjQuery object wrapping the searched component
     */
    getComponentUnderSlot(smarteditComponentId: string, smarteditComponentType: string, smarteditSlotId: string, cssClass?: string): JQuery;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getComponent
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Retrieves the yjQuery wrapper around a smartEdit component identified by its smartEdit id, smartEdit type and an optional class
     * This method can only be invoked from the smartEdit application and not the smartEdit container.
     *
     * @param {String} smarteditComponentId the component id as per the smartEdit contract with the storefront
     * @param {String} smarteditComponentType the component type as per the smartEdit contract with the storefront
     * @param {String =} cssClass the css Class to further restrict the search on. This parameter is optional.
     *
     * @return {JQuery} a yjQuery object wrapping the searched component
     */
    getComponent(smarteditComponentId: string, smarteditComponentType: string, cssClass?: string): JQuery;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getOriginalComponentWithinSlot
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Retrieves the yjQuery wrapper around a smartEdit component of the original storefront layer identified by its smartEdit id, smartEdit type and slot ID
     * This method can only be invoked from the smartEdit application and not the smartEdit container.
     *
     * @param {String} smarteditComponentId the component id as per the smartEdit contract with the storefront
     * @param {String} smarteditComponentType the component type as per the smartEdit contract with the storefront
     * @param {String} slotId the ID of the slot within which the component resides
     *
     * @return {JQuery} a yjQuery object wrapping the searched component
     */
    getOriginalComponentWithinSlot(smarteditComponentId: string, smarteditComponentType: string, slotId: string): JQuery;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getOriginalComponent
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Retrieves the yjQuery wrapper around a smartEdit component of the original storefront layer identified by its smartEdit id, smartEdit type
     * This method can only be invoked from the smartEdit application and not the smartEdit container.
     *
     * @param {String} smarteditComponentId the component id as per the smartEdit contract with the storefront
     * @param {String} smarteditComponentType the component type as per the smartEdit contract with the storefront
     *
     * @return {JQuery} a yjQuery object wrapping the searched component
     */
    getOriginalComponent(smarteditComponentId: string, smarteditComponentType: string): JQuery;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getOverlayComponentWithinSlot
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Retrieves the yjQuery wrapper around a smartEdit component of the overlay layer identified by its smartEdit id, smartEdit type and slot ID
     * This method can only be invoked from the smartEdit application and not the smartEdit container.
     *
     * @param {String} smarteditComponentId the component id as per the smartEdit contract with the storefront
     * @param {String} smarteditComponentType the component type as per the smartEdit contract with the storefront
     * @param {String} slotId the ID of the slot within which the component resides
     *
     * @return {JQuery} a yjQuery object wrapping the searched component
     */
    getOverlayComponentWithinSlot(smarteditComponentId: string, smarteditComponentType: string, slotId: string): JQuery;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getOverlayComponent
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Retrieves the yjQuery wrapper around the smartEdit component of the overlay layer corresponding to the storefront layer component passed as argument
     * This method can only be invoked from the smartEdit application and not the smartEdit container.
     *
     * @param {Object} originalComponent the DOM element in the storefront layer
     *
     * @return {JQuery} a yjQuery object wrapping the searched component
     */
    getOverlayComponent(originalComponent: JQuery): JQuery;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getComponentInOverlay
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Retrieves the yjQuery wrapper around a smartEdit component of the overlay div identified by its smartEdit id, smartEdit type
     * This method can only be invoked from the smartEdit application and not the smartEdit container.
     *
     * @param {String} smarteditComponentId the component id as per the smartEdit contract with the storefront
     * @param {String} smarteditComponentType the component type as per the smartEdit contract with the storefront
     *
     * @return {JQuery} a yjQuery object wrapping the searched component
     *
     */
    getComponentInOverlay(smarteditComponentId: string, smarteditComponentType: string): JQuery;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getParentSlotForComponent
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Retrieves the the slot ID for a given element
     *
     * @param {HTMLElement | JQuery} component the yjQuery component for which to search the parent
     *
     * @return {String} the slot ID for that particular component
     */
    getParentSlotForComponent(component: HTMLElement | JQuery): string;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getComponentPositionInSlot
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Retrieves the position of a component within a slot based on visible components in the given slotId.
     *
     * @param {String} slotId the slot id as per the smartEdit contract with the storefront
     * @param {String} componentId the component id as per the smartEdit contract with the storefront
     *
     * @return {number} the position of the component within a slot
     */
    getComponentPositionInSlot(slotId: string, componentId: string): number;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getOriginalComponentsWithinSlot
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Retrieves the yjQuery wrapper around a list of smartEdit components contained in the slot identified by the given slotId.
     * This method can only be invoked from the smartEdit application and not the smartEdit container.
     *
     * @param {String} slotId the ID of the slot within which the component resides
     *
     * @return {Array<JQuery>} The list of searched components yjQuery objects
     */
    getOriginalComponentsWithinSlot(slotId: string): JQuery[];
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getSlotOperationRelatedId
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Gets the id that is relevant to be able to perform slot related operations for this components
     * It typically is {@link seConstantsModule.CONTAINER_ID_ATTRIBUTE} when applicable and defaults to {@link seConstantsModule.ID_ATTRIBUTE}
     *
     * @param {HTMLElement | JQuery} component the yjQuery component for which to get the id
     *
     * @return {String} the slot operations related id
     */
    getSlotOperationRelatedId(component: HTMLElement | JQuery): string;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getSlotOperationRelatedUuid
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Gets the id that is relevant to be able to perform slot related operations for this components
     * It typically is {@link seConstantsModule.CONTAINER_ID_ATTRIBUTE} when applicable and defaults to {@link seConstantsModule.ID_ATTRIBUTE}
     *
     * @param {HTMLElement | JQuery} component the yjQuery component for which to get the Uuid
     *
     * @return {String} the slot operations related Uuid
     */
    getSlotOperationRelatedUuid(component: HTMLElement | JQuery): string;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getParent
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Retrieves the direct smartEdit component parent of a given component.
     * The parent is fetched in the same layer (original storefront or smartEdit overlay) as the child
     * This method can only be invoked from the smartEdit application and not the smartEdit container.
     *
     * @param {HTMLElement | JQuery} component the yjQuery component for which to search a parent
     *
     * @return {JQuery} a yjQuery object wrapping the smae-layer parent component
     */
    getParent(component: HTMLElement | JQuery): JQuery;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getClosestSmartEditComponent
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Returns the closest parent (or self) being a smartEdit component
     *
     * @param {HTMLElement | JQuery} component the DOM/yjQuery element for which to search a parent
     *
     * @return {JQuery} The closest closest parent (or self) being a smartEdit component
     */
    getClosestSmartEditComponent(component: HTMLElement | JQuery): JQuery;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#isSmartEditComponent
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Determines whether a DOM/yjQuery element is a smartEdit component
     *
     * @param {HTMLElement | JQuery} component the DOM/yjQuery element for which to check if it's a SmartEdit component
     *
     * @return {boolean} true if DOM/yjQuery element is a smartEdit component
     */
    isSmartEditComponent(component: HTMLElement | JQuery): boolean;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#setId
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Sets the smartEdit component id of a given component
     *
     * @param {HTMLElement | JQuery} component the yjQuery component for which to set the id
     * @param {String} id the id to be set
     *
     * @return {JQuery} component the yjQuery component
     */
    setId(component: HTMLElement | JQuery, id: string): JQuery;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getId
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Gets the smartEdit component id of a given component
     *
     * @param {HTMLElement | JQuery} component the yjQuery component for which to get the id
     *
     * @return {String} the component id
     */
    getId(component: HTMLElement | JQuery): string;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getUuid
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Gets the smartEdit component id of a given component
     *
     * @param {HTMLElement | JQuery} component the yjQuery component for which to get the id
     *
     * @return {String} the component id
     */
    getUuid(component: HTMLElement | JQuery): string;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getCatalogVersionUuid
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Gets the smartEdit component id of a given component
     *
     * @param {HTMLElement | JQuery} component the yjQuery component for which to get the id
     *
     * @return {String} the component id
     */
    getCatalogVersionUuid(component: HTMLElement | JQuery): string;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#setType
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Sets the smartEdit component type of a given component
     *
     * @param {HTMLElement | JQuery} component the yjQuery component for which to set the type
     * @param {String} type the type to be set
     *
     * @return {JQuery} component the yjQuery component
     */
    setType(component: HTMLElement | JQuery, type: string): JQuery;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getType
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Gets the smartEdit component type of a given component
     *
     * @param {HTMLElement | JQuery} component the yjQuery component for which to get the type
     *
     * @return {String} the component type
     */
    getType(component: HTMLElement | JQuery): string;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getSlotOperationRelatedType
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Gets the type that is relevant to be able to perform slot related operations for this components
     * It typically is {@link seConstantsModule.CONTAINER_TYPE_ATTRIBUTE} when applicable and defaults to {@link seConstantsModule.TYPE_ATTRIBUTE}
     *
     * @param {HTMLElement | JQuery} component the yjQuery component for which to get the type
     *
     * @return {String} the slot operations related type
     */
    getSlotOperationRelatedType(component: HTMLElement | JQuery): string;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getAllComponentsSelector
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Retrieves the DOM selector matching all smartEdit components that are not of type ContentSlot
     *
     * @return {String} components selector
     */
    getAllComponentsSelector(): string;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getAllSlotsSelector
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Retrieves the DOM selector matching all smartEdit components that are of type ContentSlot
     *
     * @return {String} the slots selector
     */
    getAllSlotsSelector(): string;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getParentSlotUuidForComponent
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Retrieves the the slot Uuid for a given element
     *
     * @param {JQuery} the DOM element which represents the component
     *
     * @return {String} the slot Uuid for that particular component
     */
    getParentSlotUuidForComponent(component: HTMLElement | JQuery): string;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#isExternalComponent
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Determines whether the component identified by the provided smarteditComponentId and smarteditComponentType
     * resides in a different catalog version to the one of the current page.
     *
     * @param {String} smarteditComponentId the component id as per the smartEdit contract with the storefront
     * @param {String} smarteditComponentType the component type as per the smartEdit contract with the storefront
     *
     * @return {Boolean} flag that evaluates to true if the component resides in a catalog version different to
     * the one of the current page.  False otherwise.
     */
    isExternalComponent(smarteditComponentId: string, smarteditComponentType: string): boolean;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getBodyClassAttributeByRegEx
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @param {RegExp} pattern Pattern of class names to search for
     *
     * @return {String} Class attributes from the body element of the storefront
     */
    getBodyClassAttributeByRegEx(pattern: RegExp): string;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getFirstSmartEditComponentChildren
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * This method can only be invoked from the smartEdit application and not the smartEdit container.
     * Get first level smartEdit component children for a given node, regardless how deep they are found.
     * The returned children may have different depths relatively to the parent:
     * Example: a call on the body would return 4 components with ids: 1,2,3,4
     * <pre>
     * 	<body>
     * 		<div>
     * 			<component smartedit-component-id="1">
     * 				<component smartedit-component-id="1_1"></component>
     * 			</component>
     * 			<component smartedit-component-id="2">
     * 				<component smartedit-component-id="2_1"></component>
     * 			</component>
     * 		</div>
     * 		<component smartedit-component-id="3">
     * 			<component smartedit-component-id="3_1"></component>
     * 		</component>
     * 		<div>
     * 			<div>
     * 				<component smartedit-component-id="4">
     * 					<component smartedit-component-id="4_1"></component>
     * 				</component>
     * 			</div>
     * 		</div>
     * 	</body>
     * </pre>
     *
     * @param {HTMLElement | JQuery} node any HTML/yjQuery Element
     *
     * @return {Array<JQuery>} The list of first level smartEdit component children for a given node, regardless how deep they are found.
     */
    getFirstSmartEditComponentChildren(htmlElement: HTMLElement | JQuery): JQuery[];
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getComponentCloneInOverlay
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Get component clone in overlay
     *
     * @param {JQuery} the DOM element which represents the component
     *
     * @return {JQuery} The component clone in overlay
     */
    getComponentCloneInOverlay(component: JQuery): JQuery;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:ComponentHandlerService#getAllSlotUids
     * @methodOf smarteditServicesModule.service:ComponentHandlerService
     *
     * @description
     * Get all the slot uids from the DOM
     *
     * @return {String[]} An array of slot ids in the DOM
     */
    getAllSlotUids(): string[];
    
    
}


export class ConfirmationModalService extends IConfirmationModalService {
}






/**
 * @ngdoc service
 * @name smarteditServicesModule.ContextualMenuService
 *
 * @description
 * The ContextualMenuService is used to add contextual menu items for each component.
 *
 * To add items to the contextual menu, you must call the addItems method of the contextualMenuService and pass a map
 * of the component-type array of contextual menu items mapping. The component type names are the keys in the mapping.
 * The component name can be the full name of the component type, an ant-like wildcard (such as  *middle*Suffix), or a
 * valid regex that includes or excludes a set of component types.
 *
 */
export class ContextualMenuService implements IContextualMenuService {
    
    
    onContextualMenuItemsAdded: BehaviorSubject<string>;
    
    
    /**
     * @ngdoc method
     * @name smarteditServicesModule.ContextualMenuService#addItems
     * @methodOf smarteditServicesModule.ContextualMenuService
     *
     * @description
     * The method called to add contextual menu items to component types in the SmartEdit application.
     * The contextual menu items are then retrieved by the contextual menu decorator to wire the set of menu items to the specified component.
     *
     * Sample Usage:
     * <pre>
     * contextualMenuService.addItems({
     * '.*Component': [{
     *  key: 'itemKey',
     *  i18nKey: 'CONTEXTUAL_MENU',
     *  condition: function(componentType, componentId) {
     * 	return componentId === 'ComponentType';
     * 	},
     *  callback: function(componentType, componentId) {
     * 	alert('callback for ' + componentType + "_" + componentId);
     * 	},
     *  displayClass: 'democlass',
     *  iconIdle: '.../icons/icon.png',
     *  iconNonIdle: '.../icons/icon.png',
     * }]
     * });
     * </pre>
     *
     * @param {TypedMap<IContextualMenuButton[]>} contextualMenuItemsMap A map of componentType regular experessions to list of {@link IContextualMenuButton IContextualMenuButton} contextual menu items
     *
     * The object contains a list that maps component types to arrays of {@link IContextualMenuButton IContextualMenuButton} contextual menu items. The mapping is a key-value pair.
     * The key is the name of the component type, for example, Simple Responsive Banner Component, and the value is an array of {@link IContextualMenuButton IContextualMenuButton} contextual menu items, like add, edit, localize, etc.
     */
    addItems(contextualMenuItemsMap: TypedMap<IContextualMenuButton[]>): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.ContextualMenuService#removeItemByKey
     * @methodOf smarteditServicesModule.ContextualMenuService
     *
     * @description
     * This method removes the menu items identified by the provided key.
     *
     * @param {String} itemKey The key that identifies the menu items to remove.
     */
    removeItemByKey(itemKey: string): void;
    /**
     * Verifies whether the itemKey has already been added to contextual menu list.
     *
     * @param {String} itemKey The item key to verify.
     *
     * @returns {boolean} Return true if itemKey exists in the contextual menu list, false otherwise.
     */
    containsItem(itemKey: string): boolean;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.ContextualMenuService#getContextualMenuByType
     * @methodOf smarteditServicesModule.ContextualMenuService
     *
     * @description
     * Will return an array of contextual menu items for a specific component type.
     * For each key in the contextual menus' object, the method converts each component type into a valid regex using the regExpFactory of the function module and then compares it with the input componentType and, if matched, will add it to an array and returns the array.
     *
     * @param {String} componentType The type code of the selected component
     *
     * @returns {Array} An array of contextual menu items assigned to the type.
     *
     */
    getContextualMenuByType(componentType: string): IContextualMenuButton[];
    /**
     * @ngdoc method
     * @name smarteditServicesModule.ContextualMenuService#getContextualMenuItems
     * @methodOf smarteditServicesModule.ContextualMenuService
     *
     * @description
     * Returns an object that contains a list of contextual menu items that are displayed in the menu and menu items that are added to the More … options.
     *
     * The returned object contains two arrays. The first array contains the menu items that are displayed in the menu. The display limit size (iLeftBtns) specifies
     * the maximum number of items that can be displayed in the menu. The other array contains the menu items that are available under the More... options.
     * This method decides which items to send to each array based on their priority. Items with the lowest priority are displayed in the menu. The remaining
     * items are added to the More... menu. Items that do not have a priority are automatically assigned a default priority.
     *
     * @param {IContextualMenuConfiguration} configuration the {@link IContextualMenuConfiguration IContextualMenuConfiguration}
     * @returns {Promise} A promise that resolves to an array of contextual menu items assigned to the component type.
     *
     * The returned object contains the following properties
     * - leftMenuItems : An array of menu items that can be displayed on the component.
     * - moreMenuItems : An array of menu items that are available under the more menu items action.
     *
     */
    getContextualMenuItems(configuration: IContextualMenuConfiguration): Promise<ContextualMenu>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.ContextualMenuService#refreshMenuItems
     * @methodOf smarteditServicesModule.ContextualMenuService
     *
     * @description
     * This method can be used to ask SmartEdit to retrieve again the list of items in the enabled contextual menus.
     */
    refreshMenuItems(): void;
    
    
    
    
}


export interface DecoratorMapping {
    [index: string]: string[];
}
/**
 * @ngdoc service
 * @name smarteditServicesModule.service:decoratorService
 *
 * @description
 * This service enables and disables decorators. It also maps decorators to SmartEdit component types–regardless if they are enabled or disabled.
 *
 */
export class DecoratorService implements IDecoratorService {
    
    
    
    
    
    constructor(promiseUtils: PromiseUtils, stringUtils: StringUtils, legacyDecoratorToCustomElementConverter: ILegacyDecoratorToCustomElementConverter);
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:decoratorService#addMappings
     * @methodOf smarteditServicesModule.service:decoratorService
     * @description
     * This method enables a list of decorators for a group of component types.
     * The list to be {@link smarteditServicesModule.service:decoratorService#methods_enable enable} is identified by a matching pattern.
     * The list is enabled when a perspective or referenced perspective that it is bound to is activated/enabled.
     * @param {Object} map A key-map value; the key is the matching pattern and the value is an array of decorator keys. The key can be an exact type, an ant-like wild card, or a full regular expression:
     * <pre>
     * decoratorService.addMappings({
     *  '*Suffix': ['decorator1', 'decorator2'],
     *  '.*Suffix': ['decorator2', 'decorator3'],
     *  'MyExactType': ['decorator3', 'decorator4'],
     *  '^((?!Middle).)*$': ['decorator4', 'decorator5']
     *  });
     * </pre>
     */
    addMappings(map: DecoratorMapping): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:decoratorService#enable
     * @methodOf smarteditServicesModule.service:decoratorService
     * @description
     * Enables a decorator
     *
     * @param {String} decoratorKey The key that uniquely identifies the decorator.
     * @param {Function} displayCondition Returns a promise that will resolve to a boolean that determines whether the decorator will be displayed.
     */
    enable(decoratorKey: string, displayCondition?: IDecoratorDisplayCondition): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:decoratorService#disable
     * @methodOf smarteditServicesModule.service:decoratorService
     * @description
     * Disables a decorator
     *
     * @param {String} decoratorKey the decorator key
     */
    disable(decoratorKey: string): void;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:decoratorService#getDecoratorsForComponent
     * @methodOf smarteditServicesModule.service:decoratorService
     * @description
     * This method retrieves a list of decorator keys that is eligible for the specified component type.
     * The list retrieved depends on which perspective is active.
     *
     * This method uses the list of decorators enabled by the {@link smarteditServicesModule.service:decoratorService#methods_addMappings addMappings} method.
     *
     * @param {String} componentType The type of the component to be decorated.
     * @param {String} componentId The id of the component to be decorated.
     * @returns {Promise} A promise that resolves to a list of decorator keys.
     *
     */
    getDecoratorsForComponent(componentType: string, componentId?: string): Promise<string[]>;
}










/**
 * @ngdoc service
 * @name smarteditServicesModule.service:IframeClickDetectionService
 * @extends {smarteditServicesModule.interface:IIframeClickDetectionService}
 * @description
 */
export class IframeClickDetectionService extends IIframeClickDetectionService {
    constructor(document: Document);
}

export * from './AnnouncementServiceInner';
export * from './CatalogServiceInner';
export * from './ContextualMenu';
export * from './ContextualMenuService';
export * from './DelegateRestServiceInner';
export * from './ExperienceServiceInner';
export * from './FeatureServiceInner';
export * from './NotificationServiceInner';
export * from './NotificationMouseLeaveDetectionServiceInner';
export * from './DragAndDropCrossOriginInner';
export * from './PageInfoServiceInner';
export * from './PerspectiveServiceInner';
export * from './PreviewServiceInner';
export * from './RestService';
export * from './RestServiceFactory';
export * from './SessionServiceInner';
export * from './SharedDataServiceInner';
export * from './StorageServiceInner';
export * from './UrlServiceInner';
export * from './WaitDialogServiceInner';
export * from './SeNamespaceService';
export * from './PermissionServiceInner';
export * from './AlertServiceInner';
export * from './AuthenticationServiceInner';
export * from './DecoratorService';
export * from './TranslationsFetchServiceInner';
export * from './sakExecutor/LegacyDecoratorToCustomElementConverter';
export * from './RenderServiceInner';
export * from './IframeClickDetectionServiceInner';
export * from './ToolbarServiceFactory';
export * from './resizeComponentService';
export * from './PositionRegistry';
export * from './ResizeListener';
export * from './catalogVersionPermissionServiceInner';
export * from './ComponentHandlerService';
export * from './LegacySmarteditServicesModule';
export * from './SmarteditServicesModule';
export * from './ConfirmationModalService';

/**
 * @ngdoc overview
 * @name smarteditServicesModule
 *
 * @description
 * Module containing all the services shared within the smartedit application
 */
export class LegacySmarteditServicesModule {
}








export class PermissionService extends IPermissionService {
    
    constructor(logService: LogService);
    _remoteCallRuleVerify(ruleKey: string, permissionNameObjs: PermissionContext[]): Promise<boolean>;
}




/**
 * Service aimed at determining the list of registered DOM elements that have been repositioned, regardless of how, since it was last queried
 */
export class PositionRegistry implements IPositionRegistry {
    
    
    constructor(yjQuery: YJQuery);
    /**
     * registers a given node in the repositioning registry
     */
    register(element: HTMLElement): void;
    /**
     * unregisters a given node from the repositioning registry
     */
    unregister(element: HTMLElement): void;
    /**
     * Method returning the list of nodes having been repositioned since last query
     */
    getRepositionedComponents(): HTMLElement[];
    /**
     * unregisters all nodes and cleans up
     */
    dispose(): void;
    /**
     * for e2e test purposes
     */
    _listenerCount(): number;
    
    
}





/// <reference types="angular" />
/// <reference types="jquery" />

/**
 * Internal service
 *
 * Service that resizes slots and components in the Inner Frame when the overlay is enabled or disabled.
 */
export class ResizeComponentService {
    
    
    constructor(componentHandlerService: ComponentHandlerService, yjQuery: JQueryStatic);
    /**
     * This methods appends CSS classes to inner frame slots and components. Passing a boolean true to showResizing
     * enables the resizing, and false vice versa.
     */
    resizeComponents(showResizing: boolean): void;
}

export class ResizeListener {
    
    
    constructor();
    /**
     * registers a resize listener of a given node
     */
    register(element: HTMLElement, listener: () => void): void;
    /**
     * unregisters listeners on all nodes and cleans up
     */
    dispose(): void;
    /**
     * unregisters the resize listener of a given node
     */
    unregister(element: HTMLElement): void;
    _listenerCount(): number;
}







export class LegacyDecoratorToCustomElementConverter implements ILegacyDecoratorToCustomElementConverter {
    
    
    
    constructor(upgrade: UpgradeModule, nodeUtils: NodeUtils);
    getScopes(): string[];
    convert(_componentName: string): void;
    convertIfNeeded(componentNames: string[]): void;
}


export class SakExecutorService {
    
    constructor(decoratorService: IDecoratorService);
    wrapDecorators(projectedContent: Node, element: HTMLElement): Promise<HTMLElement>;
    
}




export class SmarteditElementComponent {
    
    
    
    
    
    smarteditComponentId: string;
    smarteditComponentUuid: string;
    smarteditComponentType: string;
    smarteditContainerId: string;
    smarteditContainerType: string;
    active: boolean;
    
    
    
    
    
    
    
    
    
    
    constructor(elementRef: ElementRef, sakExecutorService: SakExecutorService, systemEventService: SystemEventService, crossFrameEventService: CrossFrameEventService, polyfillService: PolyfillService);
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    
    
    
    
    
    
    
}

declare global {
    interface Window {
        smartedit: SmarteditNamespace;
    }
}
export interface SmarteditNamespace {
    addOnReprocessPageListener: (callback: () => void) => void;
    reprocessPage: () => void;
    applications: string[];
    domain: string;
    smarteditroot: string;
    renderComponent?: (componentId: string, componentType?: string, parentId?: string) => any;
}







export class SmarteditServicesModule {
}





export class StorageModule {
}





/// <reference types="angular" />

export class ToolbarService extends IToolbarService {
    gatewayId: string;
    constructor(gatewayId: string, gatewayProxy: GatewayProxy, logService: LogService, $templateCache: angular.ITemplateCacheService, permissionService: IPermissionService);
    _removeItemOnInner(itemKey: string): void;
    triggerActionOnInner(action: {
        key: string;
    }): void;
}



export class ToolbarServiceFactory implements IToolbarServiceFactory {
    
    
    
    
    
    constructor(gatewayProxy: GatewayProxy, logService: LogService, lazy: AngularJSLazyDependenciesService, permissionService: IPermissionService);
    getToolbarService(gatewayId: string): ToolbarService;
}








export const SmarteditFactory: (payload: BootstrapPayload) => any;































declare global {
    interface Window {
        smarteditLodash: lodash.LoDashStatic;
    }
}

}