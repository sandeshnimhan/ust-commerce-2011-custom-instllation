import * as angular from 'angular';
declare module 'smarteditcontainer' {
// ******************************************************* 
// This file is automatically generated 
// Do not modify this file -- YOUR CHANGES WILL BE ERASED! 
// ******************************************************* 




/**
 * @deprecated since 2005, use AnnouncementBoardComponent
 */
export class YAnnouncementBoardComponent {
}


/**
 * @deprecated since 2005, use AnnouncementComponent
 */
export class YAnnouncementComponent {
    announcement: IAnnouncement;
}








export class ConfigurationModalComponent implements OnInit, AfterViewInit {
    editor: ConfigurationService;
    modalManager: FundamentalModalManagerService;
    
    form: NgForm;
    constructor(editor: ConfigurationService, modalManager: FundamentalModalManagerService, confirmationModalService: IConfirmationModalService);
    ngAfterViewInit(): void;
    ngOnInit(): void;
    trackByFn(_: number, item: ConfigurationItem): string;
    
    
}



export class HeartBeatAlertComponent {
    
    
    
    constructor(alertRef: AlertRef, perspectiveService: IPerspectiveService, crossFrameEventService: CrossFrameEventService);
    switchToPreviewMode(): void;
}










export * from './topToolbars';
export * from './experienceSelector/ExperienceSelectorComponent';
export * from './userAccount/UserAccountComponent';
export * from './sitesLink/SitesLinkComponent';
export * from './announcements/AnnouncementBoardComponent';
export * from './announcements/AnnouncementComponent';
export * from './announcements/yAnnouncementBoardComponent';
export * from './announcements/yAnnouncementComponent';
export * from './notifications/NotificationPanelModule';
export * from './heartBeat/HeartBeatAlertComponent';
export * from './hotkeyNotification';

/// <reference types="angular-route" />




/**
 * @ngdoc overview
 * @name LandingPageComponent
 * @description
 *
 * Component responsible of displaying the SmartEdit landing page.
 *
 */
export class LandingPageComponent implements ISeComponent {
    
    
    
    
    
    
    
    
    
    
    
    sitesId: string;
    catalogs: IBaseCatalog[];
    qualifier: string;
    field: Partial<GenericEditorField>;
    model: {
        site: string;
    };
    
    
    constructor($q: angular.IQService, $routeParams: angular.route.IRouteParamsService, $location: angular.ILocationService, siteService: SiteService, catalogService: CatalogService, systemEventService: SystemEventService, storageService: StorageService, alertService: AlertService, SITES_RESOURCE_URI: string, LINKED_DROPDOWN: string, LANDING_PAGE_PATH: string);
    $onInit(): void;
    $onDestroy(): void;
    
    
    
    
    
    
}

export class InvalidRouteComponent {
}





export class SmarteditcontainerComponent {
    
    upgrade: UpgradeModule;
    
    
    constructor(translateService: TranslateService, injector: Injector, upgrade: UpgradeModule, elementRef: ElementRef, bootstrapIndicator: AngularJSBootstrapIndicatorService);
    ngOnInit(): void;
    ngAfterViewInit(): void;
    
    
    
    
}



/**
 * This component renders an notification based on a one of the template type provided with configuration object.
 * See configuration in {@link smarteditServicesModule.interface:INotificationConfiguration INotificationConfiguration}.
 *
 * Here is an example of a notification object with a template URL:
 * {
 *     id: 'notification.identifier',
 *     templateUrl: 'notificationTemplateUrl.html'
 * }
 */
export class NotificationComponent implements OnInit {
    notification: INotificationConfiguration;
    id: string;
    ngOnInit(): void;
    hasTemplate(): boolean;
    hasTemplateUrl(): boolean;
    hasComponent(): boolean;
}





/**
 * The NotificationPanel component is responsible for getting the list of
 * notifications to display and handling showing and hiding the list when the mouse
 * pointer enters and leaves the portion of the screen occupied by the list.
 */
export class NotificationPanelComponent implements OnInit, AfterViewInit, OnDestroy {
    
    
    
    
    
    
    
    
    isMouseOver: boolean;
    notifications$: Observable<INotificationConfiguration[]>;
    
    
    
    
    
    constructor(notificationService: NotificationService, notificationMouseLeaveDetectionService: NotificationMouseLeaveDetectionService, systemEventService: SystemEventService, iframeManagerService: IframeManagerService, windowUtils: WindowUtils, element: ElementRef, yjQuery: YJQuery, cd: ChangeDetectorRef);
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    /**
     * Called when hovered on notification panel or
     * when the panel was not displayed and then notification was added.
     */
    onMouseEnter(): void;
    /**
     * Due to the fact that this function is called from a timeout, no digest cycle is
     * triggered. It has to be triggered for the template to be refreshed to make the
     * notification panel re-appear.
     */
    
    
    
    
    
    
    
    
    
    
    /**
     * This method is called when notifications has been added or removed.
     *
     * If the panel is hidden, it will re-appear.
     *
     * If the panel is hidden and a mouse position is over the panel and then the notification suddenly appears,
     * it persists hidden. For example: pressing ESC key for the Hotkey notification.
     *
     */
    
    
}

export class NotificationPanelModule {
}






/**
 * @description
 * The shortcut link configuration.
 */
export interface SeShortcutLinkConfig extends SeRouteShortcutConfig {
    active?: boolean;
}
export class ShortcutLinkComponent {
    
    
    
    
    
    containerEntry: ViewContainerRef;
    defaultTemplate: TemplateRef<any>;
    constructor(router: Router, location: Location, resolver: ComponentFactoryResolver, experienceService: IExperienceService, priorityService: PriorityService);
    ngAfterViewInit(): void;
    onClick(shortcutLink: SeShortcutLinkConfig): void;
    /**
     * Creates embedded template if the shortcut link contains titleI18nKey property otherwise
     * if the shortcut link contains shortcutComponent instance it creates a new component.
     */
    
    /**
     * Retrieves the route shortcut configs using the SeRouteService. It then generates full path replacing
     * all placeholders with values from current experience. It also verifies whether the path is active or not.
     */
    
    /**
     * Orders all shortcut links by priority. If the priority is not provided it uses the DEFAULT_PRIORITY value.
     */
    
}




export class SitesLinkComponent {
    
    
    
    cssClass: string;
    iconCssClass: string;
    shortcutLink: any;
    constructor(location: Location, iframeManagerService: IframeManagerService, LANDING_PAGE_PATH: string);
    goToSites(): void;
}




export class DeviceSupportWrapperComponent {
    toolbar: ToolbarComponent;
    constructor(toolbar: ToolbarComponent);
}


export class ExperienceSelectorWrapperComponent {
    toolbar: ToolbarComponent;
    constructor(toolbar: ToolbarComponent);
}

export * from './DeviceSupportWrapperComponent';
export * from './TopToolbarsModule';
export * from './ExperienceSelectorWrapperComponent';
export * from './LogoComponent';

export class LogoComponent {
}

export class TopToolbarsModule {
}




export class UserAccountComponent implements OnInit, OnDestroy {
    
    
    
    
    username: string;
    
    constructor(authenticationService: IAuthenticationService, iframeManagerService: IframeManagerService, crossFrameEventService: CrossFrameEventService, sessionService: ISessionService);
    ngOnInit(): void;
    ngOnDestroy(): void;
    signOut(): void;
    getUsername(): void;
}


export class CustomHandlingStrategy implements UrlHandlingStrategy {
    shouldProcessUrl(url: UrlTree): boolean;
    extract(url: UrlTree): UrlTree;
    merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree;
}

export function deprecatedSince1905(): void;
export function deprecatedSince1911(): void;
export function deprecatedSince2005(): void;
export const deprecate: () => void;





export * from '../smarteditloader';


declare global {
}
export class Smarteditcontainer {
}




export class MultiProductCatalogVersionsConfigurationsController {
    
    
    
    static productCatalogs: IBaseCatalog[];
    static selectedCatalogVersions: IBaseCatalogVersion[];
    productCatalogs: IBaseCatalog[];
    selectedCatalogVersions: IBaseCatalogVersion[];
    updatedCatalogVersions: IBaseCatalogVersion[];
    updateSelection: (updatedSelectedVersions: IBaseCatalogVersion[]) => void;
    init: () => void;
    
    
    constructor(logService: LogService, modalManager: ModalManager, systemEventService: SystemEventService);
}


export interface SelectAdaptedCatalogVersion extends IBaseCatalogVersion {
    id: string;
    label: string;
}
export interface SelectAdaptedCatalog extends IBaseCatalog {
    fetchStrategy: FetchStrategy<IBaseCatalogVersion>;
    versions: SelectAdaptedCatalogVersion[];
    selectedItem: string;
}
export class MultiProductCatalogVersionSelectorComponent {
    productCatalogs: SelectAdaptedCatalog[];
    
    
    $onInit(): void;
    updateModel: () => void;
}

/// <reference types="angular-translate" />


export const PRODUCT_CATALOG_SINGLE_TEMPLATE = "productsCatalogSelectSingleTemplate.html";
export const PRODUCT_CATALOG_MULTIPLE_TEMPLATE = "productsCatalogSelectMultipleTemplate.html";
export const MULTI_PRODUCT_CATALOGS_UPDATED = "MULTI_PRODUCT_CATALOGS_UPDATED";
export class ProductCatalogVersionsSelectorComponent {
    
    
    
    
    
    isTooltipOpen: boolean;
    initialPreview: string;
    productCatalogs: IBaseCatalog[];
    isReady: boolean;
    isSingleVersionSelector: boolean;
    isMultiVersionSelector: boolean;
    field: GenericEditorField;
    fetchStrategy: any;
    reset: () => void;
    
    
    
    
    
    
    constructor($translate: angular.translate.ITranslateService, l10nFilter: (data: TypedMap<any>) => string, catalogService: ICatalogService, modalService: IModalService, systemEventService: SystemEventService);
    $onInit(): void;
    $onDestroy(): void;
    onClick(productCatalogs: IBaseCatalog[], selectedCatalogVersions: IBaseCatalogVersion[]): void;
    parseSingleCatalogVersion(catalog: IBaseCatalog): {
        id: string;
        label: string;
    }[];
    buildMultiProductCatalogVersionsTemplate(): string;
    getMultiProductCatalogVersionsSelectedOptions(): string;
    
    
    
}

export class ProductCatalogVersionsSelectorModule {
}









/**
 * @ngdoc service
 * @name smarteditServicesModule.service:AlertFactory
 */
export class AlertFactory extends BaseAlertFactory {
    
    
    constructor(logService: LogService, domSanitizer: DomSanitizer, fundamentalAlertService: FundamentalAlertService, translateService: TranslateService, ALERT_CONFIG_DEFAULTS: AlertConfig);
    createAlert(alertConf: string | IAlertConfigLegacy | IAlertConfig): Alert;
    createInfo(alertConf: string | IAlertConfigLegacy | IAlertConfig): Alert;
    createDanger(alertConf: string | IAlertConfigLegacy | IAlertConfig): Alert;
    createWarning(alertConf: string | IAlertConfigLegacy | IAlertConfig): Alert;
    createSuccess(alertConf: string | IAlertConfigLegacy | IAlertConfig): Alert;
    /**
     * Accepts message string or config object
     * Will convert a str param to { message: str }
     */
    getAlertConfigFromStringOrConfig(strOrConf: string | IAlertConfigLegacy | IAlertConfig): IAlertConfigLegacy | IAlertConfig;
    
    
    
    
    
    /**
     * @deprecated since 1905
     */
    
}

export class AlertServiceModule {
}



/**
 * @ngdoc service
 * @name smarteditServicesModule.service:AlertService
 */
export class AlertService extends BaseAlertService implements IAlertService {
    
    constructor(_alertFactory: AlertFactory);
    showAlert(alertConf: string | IAlertConfigLegacy | IAlertConfig): void;
    showInfo(alertConf: string | IAlertConfigLegacy | IAlertConfig): void;
    showDanger(alertConf: string | IAlertConfigLegacy | IAlertConfig): void;
    showWarning(alertConf: string | IAlertConfigLegacy | IAlertConfig): void;
    showSuccess(alertConf: string | IAlertConfigLegacy | IAlertConfig): void;
}



interface ILegacyAlertConfigData {
    template?: string;
    templateUrl?: string;
    controller?: CompileHtmlNgController;
}
export class AlertTemplateComponent {
    data: ILegacyAlertConfigData;
    constructor(ref: AlertRef);
}


export * from './AlertFactory';
export * from './AlertServiceModule';
export * from './AlertServiceOuter';
export * from './AlertTemplateComponent';



export interface IAnnouncement extends IAnnouncementConfig {
    timer?: number;
    id: string;
}
export const ANNOUNCEMENT_DEFAULTS: {
    timeout: number;
    closeable: boolean;
};
export class AnnouncementService extends IAnnouncementService {
    
    
    constructor(logService: LogService);
    showAnnouncement(announcementConfig: IAnnouncementConfig): Promise<string>;
    getAnnouncements(): Observable<IAnnouncement[]>;
    closeAnnouncement(announcementId: string): Promise<void>;
    
    /**
     * Validates a given announcement data.
     * An announcement must contain only one of either message, template, or templateUrl property.
     */
    
}





export class BootstrapService {
    
    
    
    
    
    
    
    constructor(configurationExtractorService: ConfigurationExtractorService, sharedDataService: ISharedDataService, logService: LogService, httpClient: HttpClient, promiseUtils: PromiseUtils, smarteditBootstrapGateway: SmarteditBootstrapGateway, moduleUtils: ModuleUtils);
    bootstrapContainerModules(configurations: ConfigurationObject): Promise<BootstrapPayload>;
    /**
     * Retrieve SmartEdit inner application configuration and dispatch 'bundle' event with list of resources.
     * @param configurations
     */
    bootstrapSEApp(configurations: ConfigurationObject): Promise<void>;
    
    
    /**
     * Applications are considered valid if they can be retrieved over the wire
     */
    
}







export * from './BootstrapService';
export * from './ConfigurationExtractorService';
export * from './SmarteditBundle';
export * from './LoadConfigManagerService';



/**
 * @ngdoc overview
 * @name loadConfigModule
 * @description
 * The loadConfigModule supplies configuration information to SmartEdit. Configuration is stored in key/value pairs.
 * The module exposes a service which is used to load configuration as an array or object.
 */
/**
 * @ngdoc service
 * @name loadConfigModule.service:LoadConfigManagerService
 * @description
 * LoadConfigManagerService is used to retrieve configurations stored in configuration API.
 * @requires restServicefactory
 * @requires sharedDataService
 * @requires operationContextService
 * @requires logService
 * @requires promiseUtils
 * @requires resourceLocationsModule.object:CONFIGURATION_URI
 */
export class LoadConfigManagerService {
    
    
    
    
    
    
    constructor(restServicefactory: RestServiceFactory, sharedDataService: ISharedDataService, logService: LogService, promiseUtils: PromiseUtils, SMARTEDIT_RESOURCE_URI_REGEXP: RegExp, SMARTEDIT_ROOT: string);
    /**
     * @ngdoc method
     * @name loadConfigModule.service.LoadConfigManagerService#loadAsArray
     * @methodOf loadConfigModule.service:LoadConfigManagerService
     * @description
     * Retrieves configuration from an API and returns as an array of mapped key/value pairs.
     *
     * Example:
     * <pre>
     * loadConfigManagerService.loadAsArray().then(
     *   function(response) {
     *     this._prettify(response);
     *   }.bind(this));
     * </pre>
     *
     * @returns {Array} a promise of configuration values as an array of mapped configuration key/value pairs
     */
    loadAsArray(): Promise<ConfigurationItem[]>;
    /**
     * @ngdoc method
     * @name loadConfigModule.service.LoadConfigManagerService#loadAsObject
     * @methodOf loadConfigModule.service:LoadConfigManagerService
     *
     * @description
     * Retrieves a configuration from the API and converts it to an object.
     *
     * Example
     * <pre>
     * loadConfigManagerService.loadAsObject().then(function(conf) {
     *   sharedDataService.set('defaultToolingLanguage', conf.defaultToolingLanguage);
     *  });
     * </pre>
     * @returns {Object} a promise of configuration values as an object of mapped configuration key/value pairs
     */
    loadAsObject(): Promise<ConfigurationObject>;
    
    
    
}


export interface SmarteditBundleProperties {
    [index: string]: Cloneable;
    domain: string;
    smarteditroot: string;
    applications: string[];
}
export interface SmarteditBundleJsFile {
    src: string;
    namespaceToCheck?: string;
}
export interface SmarteditBundle {
    properties: SmarteditBundleProperties;
    js: SmarteditBundleJsFile[];
    css: string[];
}

/// <reference types="angular-mocks" />
/// <reference types="angular-route" />



export class CatalogAwareRouteResolverFunctions {
    /**
     * This function checks presence of a stored experience. It will redirect current user to the landing page
     * if the user doesn't have a read permission to the current catalog version. If the user has read permission for the
     * catalog version then EVENTS.EXPERIENCE_UPDATE is sent, but only when the experience has been changed.
     *
     * This function can be assigned to the resolve property of any route.
     */
    static storefrontResolve($q: angular.IQService, $log: angular.ILogService, $location: angular.ILocationService, experienceService: ExperienceService, sharedDataService: ISharedDataService, systemEventService: SystemEventService, EVENTS: any, LANDING_PAGE_PATH: string, catalogVersionPermissionService: any): PromiseLike<any>;
    /**
     * This function initializes new experience based on route params. It will redirect current user to the landing page
     * if the user doesn't have a read permission to the current catalog version. If the user has read permission for the
     * catalog version then EVENTS.EXPERIENCE_UPDATE is sent, but only when the experience has been changed.
     *
     * This function can be assigned to the resolve property of any route.
     */
    static experienceFromPathResolve($route: angular.route.IRouteService, $q: angular.IQService, $log: angular.ILogService, $location: angular.ILocationService, experienceService: ExperienceService, sharedDataService: ISharedDataService, systemEventService: SystemEventService, EVENTS: any, LANDING_PAGE_PATH: string, catalogVersionPermissionService: any): PromiseLike<any>;
    
}
export class CatalogAwareRouteResolverModule {
}




export interface CatalogVersionSyncPermission {
    canSynchronize: boolean;
    targetCatalogVersion: string;
}
export interface CatalogVersionPermissionMap {
    key: string;
    value: string;
}
export interface CatalogVersionPermission {
    catalogId: string;
    catalogVersion: string;
    permissions: CatalogVersionPermissionMap[];
    syncPermissions: CatalogVersionSyncPermission[];
}
/**
 * @ngdoc service
 * @name smarteditServicesModule.service:catalogVersionPermissionRestService
 *
 * @description
 * The catalog version permission service is used to check if the current user has been granted certain permissions
 * on a given catalog ID and catalog Version.
 */
export class CatalogVersionPermissionRestService {
    
    
    constructor(restServiceFactory: RestServiceFactory, sessionService: ISessionService);
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:catalogVersionPermissionRestService#getCatalogVersionPermissions
     * @methodOf smarteditServicesModule.service:catalogVersionPermissionRestService
     *
     * @description
     * This method returns permissions from the Catalog Version Permissions Service API.
     *
     * Sample Request:
     * GET /permissionswebservices/v1/permissions/principals/{principal}/catalogs?catalogId=apparel-deContentCatalog&catalogVersion=Online
     *
     * Sample Response from API:
     * {
     * "permissionsList": [
     *     {
     *       "catalogId": "apparel-deContentCatalog",
     *       "catalogVersion": "Online",
     *       "permissions": [
     *         {
     *           "key": "read",
     *           "value": "true"
     *         },
     *         {
     *           "key": "write",
     *           "value": "false"
     *         }
     *       ],
     *      "syncPermissions": [
     *        {
     *          "canSynchronize": "true",
     *          "targetCatalogVersion": "Online"
     *        }
     *     }
     *    ]
     * }
     *
     * Sample Response returned by the service:
     * {
     *   "catalogId": "apparel-deContentCatalog",
     *   "catalogVersion": "Online",
     *   "permissions": [
     *      {
     *        "key": "read",
     *        "value": "true"
     *      },
     *      {
     *        "key": "write",
     *        "value": "false"
     *      }
     *     ],
     *    "syncPermissions": [
     *      {
     *        "canSynchronize": "true",
     *        "targetCatalogVersion": "Online"
     *      }
     *    ]
     *  }
     *
     * @param {String} catalogId The Catalog ID
     * @param {String} catalogVersion The Catalog Version name
     *
     * @returns {Promise} A Promise which returns an object exposing a permissions array containing the catalog version permissions
     */
    getCatalogVersionPermissions(catalogId: string, catalogVersion: string): Promise<CatalogVersionPermission | {}>;
    
}



declare enum PERMISSION_TYPES {
    READ = "read",
    WRITE = "write"
}
export class CatalogVersionPermissionService extends ICatalogVersionPermissionService {
    
    
    constructor(catalogVersionPermissionRestService: CatalogVersionPermissionRestService, catalogService: ICatalogService);
    hasPermission(accessType: PERMISSION_TYPES, catalogId: string, catalogVersion: string, siteId?: string): Promise<boolean>;
    hasSyncPermissionFromCurrentToActiveCatalogVersion(): Promise<boolean>;
    hasSyncPermissionToActiveCatalogVersion(catalogId: string, catalogVersion: string): Promise<boolean>;
    hasSyncPermission(catalogId: string, sourceCatalogVersion: string, targetCatalogVersion: string): Promise<boolean>;
    hasWritePermissionOnCurrent(): Promise<boolean>;
    hasReadPermissionOnCurrent(): Promise<boolean>;
    hasWritePermission(catalogId: string, catalogVersion: string): Promise<boolean>;
    hasReadPermission(catalogId: string, catalogVersion: string): Promise<boolean>;
    /**
     * if in the context of an experience AND the catalogVersion is the active one, then permissions should be ignored in read mode
     */
    
    /**
     * Verifies whether current user has write or read permission for current catalog version.
     * @param {String} accessType
     */
    
    
}



export class ConfigurationModalService {
    
    constructor(modalService: IModalService);
    editConfiguration(): void;
}





/// <reference types="angular" />

/**
 * @ngdoc overview
 * @name confirmationModalServiceModule
 * @description
 * # The confirmationModalServiceModule
 *
 * The confirmation modal service module provides a service that allows opening a confirmation (an OK/Cancel prompt with
 * a title and content) within a modal.
 *
 * This module is dependent on the {@link modalServiceModule modalServiceModule}.
 */
/**
 * @ngdoc service
 * @name confirmationModalServiceModule.service:confirmationModalService
 *
 * @description
 * Service used to open a confirmation modal in which an end-user can confirm or cancel an action. A confirmation modal
 * consists of a title, content, and an OK and cancel button. This modal may be used in any context in which a
 * confirmation is required.
 */
export class ConfirmationModalService {
    
    constructor(modalService: IModalService);
    /**
     * @ngdoc method
     * @name confirmationModalServiceModule.service:confirmationModalService#open
     * @methodOf confirmationModalServiceModule.service:confirmationModalService
     *
     * @description
     * Uses the {@link modalServiceModule.modalService modalService} to open a confirmation modal.
     *
     * The confirmation modal is initialized by a default i18N key as a title or by an override title passed through the
     * input configuration object. The configuration object must have one and only one of the following parameters set: description, template, or templateUrl
     *
     *
     * @param {LegacyConfirmationModalConfig} LegacyConfirmationModalConfig {@link confirmationModalServiceModule.interface:LegacyConfirmationModalConfig config}
     * used to support AngularJS confirmation dialogs
     *
     * @param {ConfirmationModalConfig} ConfirmationModalConfig {@link confirmationModalServiceModule.interface:ConfirmationModalConfig config}
     * used to support Angular confirmation dialogs
     *
     * @returns {Promise | angular.IPromise} A promise that is resolved when the OK button is actioned or is rejected when the Cancel
     * button is actioned.
     */
    confirm(configuration: LegacyConfirmationModalConfig): angular.IPromise<any> | Promise<any>;
    confirm(configuration: ConfirmationModalConfig): Promise<any>;
    
    
    
    
    
    
    
}










/**
 * @ngdoc filter
 * @name smarteditServicesModule.filter:FilterByFieldFilter
 * @deprecated since 2005, use {@link FilterByFieldPipeModule.filter.FilterByFieldPipe}
 */
export class FilterByFieldFilter {
    static transform(): (items: TypedMap<string>[], query: string, keys?: string[], callbackFcn?: (filtered: TypedMap<string>[]) => void) => TypedMap<string>[];
}





export class TranslationsFetchService extends ITranslationsFetchService {
    
    
    
    constructor(httpClient: HttpClient, promiseUtils: PromiseUtils);
    get(lang: string): Promise<TranslationMap>;
    isReady(): Promise<boolean>;
    waitToBeReady(): Promise<void>;
}





/// <reference types="angular" />
/// <reference types="jquery" />
/// <reference types="eonasdan-bootstrap-datetimepicker" />




/**
 * @ngdoc service
 * @name smarteditServicesModule.service:IframeManagerService
 *
 * @description
 * The iFrame Manager service provides methods to load the storefront into an iframe. The preview of the storefront can be loaded for a specified input homepage and a specified preview ticket. The iframe src attribute is updated with that information in order to display the storefront in SmartEdit.
 */
export class IframeManagerService {
    
    
    
    
    
    
    
    constructor(logService: LogService, httpClient: HttpClient, yjQuery: JQueryStatic, windowUtils: WindowUtils, sharedDataService: ISharedDataService);
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:IframeManagerService#setCurrentLocation
     * @methodOf smarteditServicesModule.service:IframeManagerService
     *
     * @description
     * This method sets the current page location and stores it in the service. The storefront will be loaded with this location.
     *
     * @param {String} URL Location to be stored
     */
    setCurrentLocation(location: string): void;
    getIframe(): JQuery;
    isCrossOrigin(): boolean;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:IframeManagerService#load
     * @methodOf smarteditServicesModule.service:IframeManagerService
     *
     * @description
     * This method loads the storefront within an iframe by setting the src attribute to the specified input URL.
     * If this method is called within the context of a new or updated experience, prior to the loading, it will check if the page exists.
     * If the pages does not exist (the server returns a 404 and a content-type:text/html), the user will be redirected to the homepage of the storefront. Otherwise,
     * the user will be redirected to the requested page for the experience.
     *
     * @param {String} URL The URL of the storefront.
     * @param {Boolean =} checkIfFailingHTML Boolean indicating if we need to check if the page call returns a 404
     * @param {String =} homepageInPreviewMode URL of the storefront homepage in preview mode if it's a new experience
     *
     */
    load(url: string, checkIfFailingHTML?: boolean, pageInPreviewMode?: string): Promise<void>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:IframeManagerService#loadPreview
     * @methodOf smarteditServicesModule.service:IframeManagerService
     *
     * @description
     * This method loads the preview of the storefront for a specified input homepage URL or a page from the page list, and for a specified preview ticket.
     * This method will add '/cx-preview' as specified in configuration.storefrontPreviewRoute to the URI and append the preview ticket in the query string.
     * <br/>If it is an initial load,  {@link smarteditServicesModule.service:IframeManagerService#load load} will be called with this modified homepage or page from page list.
     * <br/>If it is a subsequent call, the modified homepage will be called through Ajax to initialize the preview (storefront constraint) and then
     * {@link smarteditServicesModule.service:IframeManagerService#load load} will be called with the current location.
     *
     * @param {String} homePageOrPageFromPageList The URL of the storefront homepage or a page from the page list for a given experience context.
     * @param {String} previewTicket The preview ticket.
     */
    loadPreview(homePageOrPageFromPageList: string, previewTicket: string): Promise<void>;
    apply(deviceSupport?: DeviceSupport, deviceOrientation?: DeviceOrientation): void;
    applyDefault(): void;
    
    
    
}


export class IframeClickDetectionService extends IIframeClickDetectionService {
    
    constructor();
    registerCallback(id: string, callback: () => void): () => void;
    removeCallback(id: string): boolean;
    /**
     * Triggers all callbacks currently registered to the service. This function is registered as a listener through
     * the GatewayProxy
     */
    onIframeClick(): void;
}

export * from 'smarteditcontainer/services/bootstrap';
export * from 'smarteditcontainer/services/announcement/AnnouncementServiceOuter';
export * from 'smarteditcontainer/services/notifications';
export * from 'smarteditcontainer/services/DelegateRestServiceOuter';
export * from 'smarteditcontainer/services/DragAndDropCrossOriginOuter';
export * from 'smarteditcontainer/services/ExperienceServiceOuter';



export * from 'smarteditcontainer/services/perspectives/FeatureServiceOuter';
export * from 'smarteditcontainer/services/PageInfoServiceOuter';
export * from 'smarteditcontainer/services/PreviewServiceOuter';
export * from 'smarteditcontainer/services/ProductService';
export * from 'smarteditcontainer/services/perspectives/PerspectiveServiceOuter';
export * from 'smarteditcontainer/services/SessionServiceOuter';
export * from 'smarteditcontainer/services/SharedDataServiceOuter';
export * from 'smarteditcontainer/services/SiteService';
export * from 'smarteditcontainer/services/StorageServiceOuter';

export * from 'smarteditcontainer/services/CatalogServiceOuter';
export * from 'smarteditcontainer/services/UrlServiceOuter';
export * from 'smarteditcontainer/services/WaitDialogServiceOuter';
export * from 'smarteditcontainer/services/catalogAwareRouteResolverModule';
export * from 'smarteditcontainer/services/storage';
export * from 'smarteditcontainer/services/PermissionServiceOuter';
export * from 'smarteditcontainer/services/CatalogVersionPermissionRestService';
export * from 'smarteditcontainer/services/HeartBeatService';
export * from 'smarteditcontainer/services/ConfigurationService';
export * from 'smarteditcontainer/services/IframeClickDetectionServiceOuter';
export * from './RenderServiceOuter';
export * from 'smarteditcontainer/services/http/TranslationsFetchServiceOuter';
export * from 'smarteditcontainer/services/alerts/AlertServiceModule';
export * from 'smarteditcontainer/services/catalogVersionPermissionServiceOuter';
export * from 'smarteditcontainer/services/PreviewDatalanguageDropdownPopulator';
export * from 'smarteditcontainer/services/PreviewDatapreviewCatalogDropdownPopulator';
export * from 'smarteditcontainer/services/LegacySmarteditServicesModule';
export * from 'smarteditcontainer/services/SmarteditServicesModule';
export * from 'smarteditcontainer/services/filters/FilterByFieldFilter';
export * from 'smarteditcontainer/services/ConfirmationModalServiceOuter';
export * from 'smarteditcontainer/services/toolbar';
export * from 'smarteditcontainer/services/ConfigurationModalService';






export class InflectionPointSelectorComponent implements OnInit, OnDestroy {
    
    
    
    
    points: DeviceSupport[];
    currentPointSelected: DeviceSupport | undefined;
    isOpen: boolean;
    
    
    constructor(systemEventService: SystemEventService, iframeManagerService: IframeManagerService, iframeClickDetectionService: IframeClickDetectionService, yjQuery: YJQuery);
    ngOnInit(): void;
    ngOnDestroy(): void;
    selectPoint(choice: DeviceSupport): void;
    toggleDropdown(event: MouseEvent): void;
    getIconClass(choice: DeviceSupport | undefined): string;
    isSelected(choice: DeviceSupport | undefined): boolean;
}

/**
 * @ngdoc overview
 * @name smarteditServicesModule
 *
 * @description
 * Module containing all the services shared within the smartedit container application
 */
export class LegacySmarteditServicesModule {
}

export * from './NotificationServiceOuter';
export * from './NotificationMouseLeaveDetectionServiceOuter';








/**
 * @ngdoc object
 * @name smarteditServicesModule.object:DEFAULT_RULE_NAME
 * @description
 * The name used to register the default rule.
 */
export const DEFAULT_DEFAULT_RULE_NAME = "se.permission.service.default.rule";
export type RulePermissionNames = TypedMap<PermissionContext[]>;
export class PermissionService extends IPermissionService {
    
    
    
    static resetForTests(): void;
    
    
    
    
    
    constructor(logService: LogService, systemEventService: SystemEventService, crossFrameEventService: CrossFrameEventService);
    getPermission(permissionName: string): Permission;
    unregisterDefaultRule(): void;
    registerPermission(permission: Permission): void;
    hasCachedResult(ruleName: string, key: string): boolean;
    clearCache(): void;
    isPermitted(permissions: MultiNamePermissionContext[]): Promise<boolean>;
    /**
     * This method adds a promise obtained by calling the pre-configured rule.verify function to the rulePromises
     * map if the result does not exist in the rule's cache. Otherwise, a promise that contains the cached result
     * is added.
     *
     * The promise obtained from the rule.verify function is chained to allow short-circuiting the permission
     * verification process. If a rule resolves with a false result or with an error, the chained promise is
     * rejected to stop the verification process without waiting for all other rules to resolve.
     *
     * @param {Object} rulePromises An object that maps rule names to promises.
     * @param {Object} rulePermissionNames An object that maps rule names to permission name arrays.
     * @param {String} ruleName The name of the rule to verify.
     */
    
    /**
     * This method validates a permission name. Permission names need to be prefixed by at least one
     * namespace followed by a "." character to be valid.
     *
     * Example: se.mynamespace is valid.
     * Example: mynamespace is not valid.
     */
    
    /**
     * This method returns an object that maps rule names to promises.
     */
    
    /**
     * This method returns true if a default rule is already registered.
     *
     * @returns {boolean} true if the default rule has been registered, false otherwise.
     */
    
    /**
     * This method returns the rule's cached result for the given key.
     *
     * @param {Object} ruleName The name of the rule for which to lookup the cached result.
     * @param {String} key The cached key to lookup..
     *
     * @returns {Boolean} The cached result, if it exists, null otherwise.
     */
    
    /**
     * This method generates a key to store a rule's result for a given combination of
     * permissions in its cache. It is done by sorting the list of permissions by name
     * and serializing it.
     *
     * @param {Object[]} permissions A list of permissions with a name and context.
     *
     * [{
     *     name: "permission.name"
     *     context: {
     *         key: "value"
     *     }
     * }]
     *
     * @returns {String} The serialized sorted list of permissions.
     */
    
    /**
     * This method goes through the permission name arrays associated to rule names to remove any duplicate
     * permission names.
     *
     * If one or more permission names with the same context are found in a rule name's permission name array,
     * only one entry is kept.
     */
    
    /**
     * This method returns an object mapping rule name to permission name arrays.
     *
     * It will iterate through the given permission name object array to extract the permission names and contexts,
     * populate the map and clean it up by removing duplicate permission name and context pairs.
     */
    
    /**
     * This method will populate rulePermissionNames with the rules associated to the permission with the given
     * permissionName.
     *
     * If no permission is registered with the given permissionName and a default rule is registered, the default
     * rule is added to rulePermissionNames.
     *
     * If no permission is registered with the given permissionName and no default rule is registered, an error
     * is thrown.
     */
    
    /**
     * This method will add an object with the permissionName and permissionContext to rulePermissionNames.
     *
     * Since rules can have multiple names, the map will use the first name in the rule's name list as its key.
     * This way, each rule will be called only once for every permission name and context.
     *
     * If the rule associated to a given rule name is already in rulePermissionNames, the permission will be
     * appended to the associated array. Otherwise, the rule name is added to the map and its permission name array
     * is created.
     */
    
    /**
     * This method returns the rule registered with the given name.
     *
     * @param {String} ruleName The name of the rule to lookup.
     *
     * @returns {Object} rule The rule with the given name, undefined otherwise.
     */
    
    
    
    
    
    
    
    
    
    
}







/// <reference types="angular" />
/// <reference types="jquery" />


export class PerspectiveSelectorComponent implements OnInit, OnDestroy {
    
    
    
    
    
    
    
    isOpen: boolean;
    isDisabled: boolean;
    
    
    
    
    
    
    
    
    
    constructor(logService: LogService, yjQuery: JQueryStatic, perspectiveService: IPerspectiveService, iframeClickDetectionService: IIframeClickDetectionService, systemEventService: SystemEventService, crossFrameEventService: CrossFrameEventService, testModeService: TestModeService);
    onDocumentClick(event: Event): void;
    ngOnInit(): void;
    ngOnDestroy(): void;
    selectPerspective(event: Event, choice: string): void;
    getDisplayedPerspectives(): IPerspective[];
    getActivePerspectiveName(): string;
    hasActivePerspective(): boolean;
    isTooltipVisible(): boolean;
    
    
    
    
    
    
    
    
}


/**
 * Implementation of smarteditcommons' DropdownPopulatorInterface for language dropdown in
 * experience selector to populate the list of languages by making a REST call to retrieve the list of langauges for a given site.
 *
 */
export class PreviewDatalanguageDropdownPopulator extends DropdownPopulatorInterface {
    constructor(languageService: LanguageService);
    /**
     * Returns a promise resolving to a list of languages for a given Site ID (based on the selected catalog). The site Id is generated from the
     * selected catalog in the 'catalog' dropdown.
     */
    populate(payload: DropdownPopulatorPayload): Promise<GenericEditorOption[]>;
}



/**
 * Implementation of DropdownPopulatorInterface for catalog dropdown in
 * experience selector to populate the list of catalogs by making a REST call to retrieve the sites and then the catalogs based on the site.
 */
export class PreviewDatapreviewCatalogDropdownPopulator extends DropdownPopulatorInterface {
    
    
    
    constructor(catalogService: ICatalogService, siteService: SiteService, languageService: LanguageService, crossFrameEventService: CrossFrameEventService);
    /**
     *  Returns a promise resolving to a list of site - catalogs to be displayed in the experience selector.
     *
     */
    populate(payload: DropdownPopulatorPayload): Promise<GenericEditorOption[]>;
}




/**
 * Interface used by ProductService for product search
 */
export interface IProductSearch {
    /**
     * id of the catalog
     */
    catalogId: string;
    /**
     * version of the catalog
     */
    catalogVersion: string;
}
/**
 * @ngdoc service
 * @name smarteditServicesModule.service:ProductService
 * @description
 * The ProductService provides is used to access products from the product catalog
 */
export class ProductService {
    
    
    
    
    constructor(restServiceFactory: RestServiceFactory, languageService: LanguageService);
    /**
     * Returns a Product that matches the given siteUID and productUID
     */
    getProductById(siteUID: string, productUID: string): Promise<IProduct>;
    /**
     * Returns a list of Products from the catalog that match the given mask
     */
    findProducts(productSearch: IProductSearch, pageable: Pageable): Promise<Page<IProduct>>;
    
}








/**
 * @ngdoc service
 * @name smarteditServicesModule.service:SiteService
 *
 * @description
 * The Site Service fetches all sites configured on the hybris platform using REST calls to the cmswebservices sites API.
 */
export class SiteService {
    
    
    
    
    constructor(restServiceFactory: RestServiceFactory);
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:SiteService#getAccessibleSites
     * @methodOf smarteditServicesModule.service:SiteService
     *
     * @description
     * Fetches a list of sites for which user has at-least read access to one of the non-active catalog versions.
     *
     * @returns {Object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of {@link smarteditServicesModule.interface:ISite ISite} array.
     */
    getAccessibleSites(): Promise<ISite[]>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:SiteService#getSites
     * @methodOf smarteditServicesModule.service:SiteService
     *
     * @description
     * Fetches a list of sites configured for accessible sites. The list of sites fetched using REST calls through
     * the cmswebservices sites API.
     *
     * @returns {Object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of {@link smarteditServicesModule.interface:ISite ISite} array.
     */
    getSites(): Promise<ISite[]>;
    /**
     * @ngdoc method
     * @name smarteditServicesModule.service:SiteService#getSiteById
     * @methodOf smarteditServicesModule.service:SiteService
     *
     * @description
     * Fetches a site, configured on the hybris platform, by its uid. The sites fetched using REST calls through
     * cmswebservices sites API.
     * @param {String} uid unique site ID
     * @returns {object} A {@link https://docs.angularjs.org/api/ng/service/$q promise} of {@link smarteditServicesModule.interface:ISite ISite}.
     */
    getSiteById(uid: string): Promise<ISite>;
}

export class SmarteditServicesModule {
}





















export * from './controller/memorystorage/MemoryStorageController';
export * from './controller/memorystorage/MemoryStorage';
export * from './controller/webstorage/AbstractWebStorageController';
export * from './controller/webstorage/LocalStorageController';
export * from './controller/webstorage/SessionStorageController';
export * from './controller/webstorage/WebStorage';
export * from './controller/webstorage/WebStorageBridge';
export * from './gateway/StorageManagerGatewayOuter';
export * from './gateway/StorageGatewayOuter';
export * from './manager/StorageManager';
export * from './metadata/MetaDataMapStorage';
export * from './metadata/IStorageMetaData';
export * from './defaultStorageProperties';
export * from './StorageModuleOuter';
export * from './StoragePropertiesService';









export class StorageModule {
    static forRoot(properties?: TypedMap<any>): ModuleWithProviders;
}




export interface ISessionAuth {
    [index: string]: IAuthToken | any;
}

export * from './ToolbarComponent';
export * from './ToolbarActionComponent';
export * from './ToolbarActionOutletComponent';
export * from './ToolbarItemContextComponent';
export * from './ToolbarSectionItemComponent';











export * from './services';
export * from './components';
export * from './ToolbarModule';

export * from './ToolbarService';
export * from './ToolbarServiceFactory';

/// <reference types="angular" />

export class ToolbarService extends IToolbarService {
    gatewayId: string;
    
    constructor(gatewayId: string, gatewayProxy: GatewayProxy, logService: LogService, $templateCache: angular.ITemplateCacheService, permissionService: IPermissionService);
    addAliases(aliases: ToolbarItemInternal[]): void;
    /**
     * @ngdoc method
     * @name smarteditCommonsModule.IToolbarService#removeItemByKey
     * @methodOf smarteditCommonsModule.IToolbarService
     *
     * @description
     * This method removes the action and the aliases of the toolbar item identified by
     * the provided key.
     *
     * @param {String} itemKey - Identifier of the toolbar item to remove.
     */
    removeItemByKey(itemKey: string): void;
    removeAliasByKey(itemKey: string): void;
    setOnAliasesChange(onAliasesChange: (aliases: ToolbarItemInternal[]) => void): void;
    triggerAction(action: ToolbarItemInternal): void;
    
    
}



export class ToolbarServiceFactory implements IToolbarServiceFactory {
    
    
    
    
    
    constructor(gatewayProxy: GatewayProxy, logService: LogService, lazy: AngularJSLazyDependenciesService, permissionService: IPermissionService);
    getToolbarService(gatewayId: string): ToolbarService;
}

export class ToolbarModule {
}





/**
 * @ngdoc overview
 * @name CatalogDetailsModule
 * @description
 * This module contains the {@link CatalogDetailsModule.component:catalogVersionDetails} component.
 */
/**
 * @ngdoc object
 * @name CatalogDetailsModule.object:CATALOG_DETAILS_COLUMNS
 *
 * @description
 * Injectable angular constant<br/>
 * This object provides an enumeration with values for each of the possible places to add items to
 * extend the {@link CatalogDetailsModule.component:catalogVersionDetails} component. Currently,
 * the available options are CATALOG_DETAILS_COLUMNS.LEFT and CATALOG_DETAILS_COLUMNS.RIGHT.
 *
 */
export class CatalogDetailsModule {
}



/**
 * @ngdoc component
 * @name CatalogDetailsModule.component:catalogDetails
 * @element se-catalog-details
 *
 * @description
 * Component responsible for displaying a catalog details. It contains a thumbnail representing the whole
 * catalog and the list of catalog versions available to the current user.
 *
 * This component is currently used in the landing page.
 *
 * @param {< String} catalog The catalog that needs to be displayed
 * @param {< Boolean} isCatalogForCurrentSite A flag that specifies if the provided catalog is associated with the selected site in the landing page
 */
export class CatalogDetailsComponent implements OnInit {
    
    catalog: ICatalog;
    isCatalogForCurrentSite: boolean;
    activeCatalogVersion: ICatalogVersion;
    siteIdForCatalog: string;
    sortedCatalogVersions: ICatalogVersion[];
    collapsibleConfiguration: {
        expandedByDefault: boolean;
    };
    catalogDividerImage: string;
    constructor(catalogService: ICatalogService);
    ngOnInit(): void;
    
}



/**
 * @ngdoc component
 * @name CatalogDetailsModule.component:catalogVersionDetails
 * @element se-catalog-version-details
 *
 * @description
 * Component responsible for displaying a catalog version details. Contains a link, called homepage, that
 * redirects to the default page with the right experience (site, catalog, and catalog version).
 *
 * Can be extended with custom items to provide new links and functionality.
 *
 * @param {<Object} catalog Object representing the parent catalog of the catalog version to display.
 * @param {<Object} catalogVersion Object representing the catalog version to display.
 * @param {<Object} activeCatalogVersion Object representing the active catalog version of the parent catalog.
 * @param {<String} siteId The site associated with the provided catalog.
 */
export class CatalogVersionDetailsComponent implements OnInit {
    
    catalog: ICatalog;
    catalogVersion: ICatalogVersion;
    activeCatalogVersion: ICatalogVersion;
    siteId: string;
    leftItems: CatalogDetailsItem[];
    rightItems: CatalogDetailsItem[];
    constructor(catalogDetailsService: ICatalogDetailsService);
    ngOnInit(): void;
}



export class CatalogVersionItemRendererComponent implements OnInit, OnChanges {
    
    item: CatalogDetailsItem;
    catalog: ICatalog;
    catalogVersion: ICatalogVersion;
    activeCatalogVersion: ICatalogVersion;
    siteId: string;
    legacyController: CompileHtmlNgController;
    itemInjector: Injector;
    constructor(injector: Injector);
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    
    
}



/**
 * @ngdoc component
 * @name CatalogDetailsModule.component:catalogVersionsThumbnailCarousel
 * @element se-catalog-versions-thumbnail-carousel
 *
 * @description
 * Component responsible for displaying a thumbnail of the provided catalog. When clicked,
 * it redirects to the storefront page for the catalog's active catalog version.
 *
 * @param {< Object} catalog Object representing the current catalog.
 * @param {< String} siteId The ID of the site associated with the provided catalog.
 */
export class CatalogVersionsThumbnailCarouselComponent implements OnInit {
    
    catalog: ICatalog;
    siteId: string;
    selectedVersion: ICatalogVersion;
    constructor(experienceService: IExperienceService);
    ngOnInit(): void;
    onClick(): void;
    
}


/**
 * @ngdoc component
 * @name CatalogDetailsModule.directive:homePageLink
 * @element <se-home-page-link></home-page-link>
 *
 * @description
 * Directive that displays a link to the main storefront page.
 *
 * @param {< Object} catalog Object representing the provided catalog.
 * @param {< Boolean} catalogVersion Object representing the provided catalog version.
 * @param {< String} siteId The ID of the site the provided catalog is associated with.
 */
export class HomePageLinkComponent {
    
    
    constructor(experienceService: IExperienceService, data: CatalogDetailsItemData);
    onClick(): void;
}

/**
 * @ngdoc directive
 * @name CatalogDetailsModule.component:catalogDetails
 * @scope
 * @deprecated since 2005
 * @restrict E
 * @element catalog-details
 *
 * @description
 * Deprecated, use <se-catalog-details>
 * Component responsible for displaying a catalog details. It contains a thumbnail representing the whole
 * catalog and the list of catalog versions available to the current user.
 *
 * This component is currently used in the landing page.
 *
 * @param {< String} catalog The catalog that needs to be displayed
 * @param {< Boolean} isCatalogForCurrentSite A flag that specifies if the provided catalog is associated with the selected site in the landing page
 */
export class LegacyCatalogDetailsComponent {
}

/**
 * @ngdoc directive
 * @name CatalogDetailsModule.component:catalogVersionDetails
 * @scope
 * @deprecated since 2005
 * @restrict E
 * @element catalog-version-details
 *
 * @description
 * Deprecated, use <se-catalog-version-details>
 * Component responsible for displaying a catalog version details. Contains a link, called homepage, that
 * redirects to the default page with the right experience (site, catalog, and catalog version).
 *
 * Can be extended with custom items to provide new links and functionality.
 *
 * @param {<Object} catalog Object representing the parent catalog of the catalog version to display.
 * @param {<Object} catalogVersion Object representing the catalog version to display.
 * @param {<Object} activeCatalogVersion Object representing the active catalog version of the parent catalog.
 * @param {<String} siteId The site associated with the provided catalog.
 */
export class LegacyCatalogVersionDetailsComponent {
}

/**
 * @ngdoc directive
 * @name CatalogDetailsModule.directive:homePageLink
 * @scope
 * @restrict E
 * @deprecated since 2005
 * @element <home-page-link></home-page-link>
 *
 * @description
 * Deprecated, use <se-home-page-link>
 * Directive that displays a link to the main storefront page.
 *
 * @param {< Object} catalog Object representing the provided catalog.
 * @param {< Boolean} catalogVersion Object representing the provided catalog version.
 * @param {< String} siteId The ID of the site the provided catalog is associated with.
 */
export class LegacyHomePageLinkComponent {
}

export class LegacyCatalogDetailsModule {
}


/**
 * @ngdoc service
 * @name CatalogDetailsModule.service:catalogDetailsService
 * @description
 *
 * The catalog details Service makes it possible to add items in form of directive
 * to the catalog details directive
 *
 */
export class CatalogDetailsService implements ICatalogDetailsService {
    
    constructor();
    /**
     * @ngdoc method
     * @name CatalogDetailsModule.service:catalogDetailsService#addItems
     * @methodOf CatalogDetailsModule.service:catalogDetailsService
     *
     * @description
     * This method allows to add a new item/items to the template array.
     *
     * @param {Array} items An array that hold a list of items.
     * @param {String=} column The place where the template will be added to. If this value is empty
     * the template will be added to the left side by default. The available places are defined in the
     * constant {@link CatalogDetailsModule.object:CATALOG_DETAILS_COLUMNS}
     */
    addItems(items: CatalogDetailsItem[], column?: string): void;
    /**
     * @ngdoc method
     * @name CatalogDetailsModule.service:catalogDetailsService#getItems
     * @methodOf CatalogDetailsModule.service:catalogDetailsService
     *
     * @description
     * This retrieves the list of items currently extending catalog version details components.
     */
    getItems(): {
        left: CatalogDetailsItem[];
        right: CatalogDetailsItem[];
    };
}





/// <reference types="angular" />
/// <reference types="angular-translate" />

declare type ClientPagedListScope = ClientPagedList & angular.IScope;
/**
 * @ngdoc component
 * @name LegacyClientPagedListModule.component:LegacyClientPagedListComponent
 *
 * @deprecated since 2005, use {@link smarteditCommonsModule.module:ClientPagedListModule.component:ClientPagedListComponent ClientPagedListComponent}
 *
 * @description
 * Component responsible for displaying a client-side paginated list of items with custom renderers. It allows the user to search and sort the list.
 *
 * @param {Array} items An array of item descriptors.
 * @param {Array} keys An array of object(s) with a property and an i18n key.
 * The properties must match one at least one of the descriptors' keys and will be used as the columns of the table. The related i18n keys are used for the column headers' title.
 * @param {Object} renderers An object that contains HTML renderers for specific keys property. A renderer is a function that returns a HTML string. This function accepts two arguments: "item" and "key".
 * @param {Object} injectedContext An object that exposes values or functions to the component. It can be used by the custom HTML renderers to bind a function to a click event for example.
 * @param {Boolean} reversed If set to true, the list will be sorted descending.
 * @param {Number} itemsPerPage The number of items to display per page.
 * @param {Object} query The ngModel query object used to filter the list.
 * @param {Boolean} displayCount If set to true the size of the filtered collection will be displayed.
 * @param {Array} itemFilterKeys (OPTIONAL) An array of object keys that will determine which fields the "LegacyFilterByFieldFilter"
 * will use to filter through the items.
 *
 * @example
 * <pre>
 *          <client-paged-list items="pageListCtl.pages"
 *                      keys="[{
 *                              property:'title',
 *                              i18n:'pagelist.headerpagetitle'
 *                              },{
 *                              property:'uid',
 *                              i18n:'pagelist.headerpageid'
 *                              },{
 *                              property:'typeCode',
 *                              i18n:'pagelist.headerpagetype'
 *                              },{
 *                              property:'template',
 *                              i18n:'pagelist.headerpagetemplate'
 *                              }]"
 *                      renderers="pageListCtl.renderers"
 *                      injectedContext="pageListCtl.injectedContext"
 *                      sort-by="'title'"
 *                      reversed="true"
 *                      items-per-page="10"
 *                      query="pageListCtl.query.value"
 *                      display-count="true"
 *            ></paged-list>
 * </pre>
 *
 * <em>Example of a <strong>renderers</strong> object</em>
 *
 * <pre>
 *          renderers = {
 *              name: function(item, key) {
 *                  return "<a data-ng-click=\"injectedContext.onLink( item.path )\">{{ item[key.property] }}</a>";
 *              }
 *          };
 * </pre>
 *
 * <em>Example of an <strong>injectedContext</strong> object</em>
 * <pre>
 *          injectedContext = {
 *              onLink: function(link) {
 *                  if (link) {
 *                      var experiencePath = this._buildExperiencePath();
 *                      iframeManagerService.setCurrentLocation(link);
 *                      $location.path(experiencePath);
 *                  }
 *              }.bind(this)
 *          };
 * </pre>
 *
 */
export class LegacyClientPagedListComponent implements Partial<ClientPagedListScope> {
    
    
    items: ClientPagedListItem[];
    itemsPerPage: number;
    totalItems: number;
    keys: ClientPagedListColumnKey[];
    renderers: TypedMap<() => string>;
    injectedContext: TypedMap<(...args: []) => any>;
    identifier: string | undefined;
    sortBy: string;
    reversed: boolean;
    query: string;
    displayCount: boolean;
    dropdownItems: IDropdownMenuItem[];
    selectedItem: ClientPagedListItem | undefined;
    itemFilterKeys: string[];
    readonly currentPage: number;
    columnWidth: number;
    columnToggleReversed: boolean;
    headersSortingState: TypedMap<boolean>;
    visibleSortingHeader: string;
    constructor($scope: ClientPagedListScope, $filter: angular.IFilterService);
    $onInit(): void;
    filterCallback: (filteredList: ClientPagedListItem[]) => void;
    getFilterKeys: () => string[];
    orderByColumn: (columnKey: string) => void;
}


/**
 * @ngdoc overview
 * @name LegacyClientPagedListModule
 * @deprecated since 2005, use {@link ClientPagedListModule ClientPagedListModule}
 */
export class ClientPagedListModule {
}


export const SmarteditContainerFactory: (bootstrapPayload: BootstrapPayload) => any;

}